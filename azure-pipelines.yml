# Docker
# Build and push an image to Azure Container Registry
# https://docs.microsoft.com/azure/devops/pipelines/languages/docker

trigger:
  - develop

resources:
  containers:
    - container: mongo
      image: mongo:4.4
      ports:
        - 27017:27017
  repositories:
    - repository: self

variables:
  # Container registry service connection established during pipeline creation
  dockerRegistryServiceConnection: 'eb58b582-7fd4-4332-b26b-eca2e488fea3'
  imageRepository: 'time-record-service'
  containerRegistry: 'coding4u.azurecr.io'
  dockerfilePath: '$(Build.SourcesDirectory)/.docker/Dockerfile.prod'
  tag: |
    $(Build.BuildId)
    latest

  # Agent VM image name
  # vmImageName: 'ubuntu-latest'
  agentPools: Default

  isDev: $[eq(variables['Build.SourceBranch'], 'refs/heads/develop')]

stages:
  - stage: BuildTest
    displayName: Build and Test

    jobs:
      - job: BuildTest
        displayName: Build and Test Time Record Service
        strategy:
          matrix:
            Go_1_16:
              go.version: '1.16'
        pool:
          $(agentPools)
          # vmImage: $(vmImageName)

        services:
          mongo: mongo

        steps:
          - task: GoTool@0
            inputs:
              version: $(go.version)
            displayName: 'Install and select Go version $(go.version)'

          - script: |
              # Get tools for converting Go's test reports
              go get -u github.com/jstemmer/go-junit-report 2>&1
              go get -u github.com/axw/gocov/gocov 2>&1
              go get -u github.com/AlekSi/gocov-xml 2>&1
              go get -u github.com/matm/gocov-html 2>&1

              # Run Go tests and turn output into JUnit test result format
              go test -v -coverprofile=coverage.txt -covermode count ./... 2>&1 | $HOME/go/bin/go-junit-report > report.xml
              rc=${PIPESTATUS[0]} # Get result code of `go test`

              mkdir coverage
              # Convert coverage file into XML
              $HOME/go/bin/gocov convert coverage.txt > coverage.json
              $HOME/go/bin/gocov-xml < coverage.json > coverage.xml
              $HOME/go/bin/gocov-html < coverage.json > coverage/index.html

              # Check if `go test` had an error
              if [ $rc -ne 0 ]; then
                # Let script fail by writing to stderr
                >&2 echo "Tests failed"
              fi
            displayName: 'Run unit tests and convert results'
            failOnStderr: true

          - task: Go@0
            inputs:
              command: 'build'
              arguments: '-a -o main'
            displayName: 'Build Go app'

          - publish: '$(Build.SourcesDirectory)/main'
            artifact: 'Executable'
            displayName: 'Publish pipeline artifact'

          - task: PublishTestResults@2
            condition: always()
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: '*report*.xml'
              searchFolder: '$(Build.SourcesDirectory)'
            displayName: 'Publish test results'

          - task: PublishCodeCoverageResults@1
            condition: always()
            inputs:
              codeCoverageTool: Cobertura
              summaryFileLocation: $(Build.SourcesDirectory)/coverage.xml
              reportDirectory: $(Build.SourcesDirectory)/**/coverage
            displayName: 'Publish code coverage results'

  - stage: PublishImage
    condition: and(succeeded(), eq(variables.isDev, true))
    displayName: 'Publish Docker Image'

    jobs:
      - job: PublishImage
        displayName: 'Publish Docker Image'
        strategy:
          matrix:
            Go_1_16:
              go.version: '1.16'
        pool:
          $(agentPools)
          # vmImage: $(vmImageName)

        steps:
          - task: Docker@2
            displayName: Build and push an image to container registry
            inputs:
              command: buildAndPush
              buildContext: $(Build.SourcesDirectory)
              repository: $(imageRepository)
              dockerfile: $(dockerfilePath)
              containerRegistry: $(dockerRegistryServiceConnection)
              tags: |
                $(tag)
